Office‚Äëstamper 3.0 is released. This version modernizes the core processing algorithm and configuration API.
It delivers more consistent behavior and clearer extension points, but introduces breaking changes you should
review before upgrading.

## üîÑ What changed (at a glance)

### Processing order overhaul

The most significant update: all elements (placeholders and comments) are now processed in document order of
appearance. Previously, processing was grouped (comments first with enclosed placeholders, then inline processors,
then left‚Äëover placeholders).

What this means for you:

- If you had comments and placeholders on the same lines, resolution order will change.
- More predictable and intuitive processing flow
- Better support for interdependent elements

### Custom processors and context

- Removal of the old `ParagraphPlaceholder` injection into custom `CommentProcessor` implementations.
- New hierarchical context system with `ContextTree` and `ContextBranch` that manages nested scopes for evaluation.
- Processors receive a `ProcessorContext` and should iterate over the hooks context they want to update with nested scopes.
- Cleaner separation of concerns: processors focus on document changes; the engine handles expression evaluation.

### Nested context resolution and evaluation context

- `OfficeStamperEvaluationContextFactory` now creates a fresh `EvaluationContext` per hook.
- Union resolvers (`UnionPropertyAccessor`, `UnionIndexAccessor`, `UnionMethodResolver`) resolve properties, indexes,
  and methods along the current `ContextBranch` from deepest to root (with shadowing semantics).
- Placeholders inside repeated/nested structures can reference values defined in outer scopes.
- No config changes required to benefit from this; it is built into v3.

### API cleanup

- All deprecated methods removed.
- `DocxDocument` interface removed (merged into `DocxPart`).
- Unnecessary setters removed for better immutability.
- Streamlined configuration API.
- Removed `ExpressionResolver` in favor of using an `ExpressionParser` (typically `SpelExpressionParser`) inside
  `Engine`.
- `Comment` interface: removed `getDocument()`.
- `CommentUtil`: `createSubWordDocument` now requires a `sourceDocument` parameter.

### Pluggable expression parsing

The engine now accepts a generic `org.springframework.expression.ExpressionParser` throughout. You can:

- Keep using SpEL (default). Construct `SpelExpressionParser` with your `SpelParserConfiguration` and pass it into the
  configuration.
- Swap in an alternative `ExpressionParser` implementation if you prefer not to depend on SpEL.

Migration examples:

- Before (v2.x; parser implicit):

  ```java
  // v2.x style (conceptual):
  var config = standard();
  // SpEL features were controlled via SpelParserConfiguration in internal components.
  ```

- After (v3): pass an `ExpressionParser` explicitly

  ```java
  import org.springframework.expression.ExpressionParser;
  import org.springframework.expression.spel.SpelParserConfiguration;
  import org.springframework.expression.spel.standard.SpelExpressionParser;

  var spelConfig = new SpelParserConfiguration(true, true); // auto-grow lists, null-safe navigation, etc.
  ExpressionParser parser = new SpelExpressionParser(spelConfig);

  var config = standard()
      .setExpressionParser(parser);
  ```

Notes:

- SpEL remains the default. Providing your own parser is optional.
- With SpEL, language features are controlled at parser construction time via `SpelParserConfiguration`.
- Any custom parser must implement Spring‚Äôs `ExpressionParser` interface.

### EvaluationContext: Configurer ‚Üí Factory (BREAKING)

`EvaluationContextConfigurer` has been replaced with `EvaluationContextFactory` (creation over mutation). This aligns
with hierarchical context and avoids side effects when multiple contexts are created during processing.

What changed:

- Interface rename and responsibility shift:
    - `EvaluationContextConfigurer#configureEvaluationContext(StandardEvaluationContext)` ‚Üí
      `EvaluationContextFactory#create(Object root)` returning a new `EvaluationContext`.
- Preset utilities renamed and modernized:
    - `EvaluationContextConfigurers.defaultConfigurer()` ‚Üí `EvaluationContextFactories.defaultFactory()`
    - `EvaluationContextConfigurers.noopConfigurer()` ‚Üí `EvaluationContextFactories.noopFactory()`
- Configuration API now expects a factory via `OfficeStamperConfiguration#setEvaluationContextFactory(...)`.

Why this matters:

- Each evaluation context is created fresh for a root object/branch, avoiding cross‚Äëcontamination between steps.
- Safer defaults: the default factory restricts dangerous features (constructor/method resolution, type lookup, bean
  resolution) but allows map and data‚Äëbinding accessors.
- Clearer lifecycle: no mutating a shared `StandardEvaluationContext`; always return a fully configured context.

Migration examples:

- Before (v2.x):

  ```java
  import static pro.verron.officestamper.preset.EvaluationContextConfigurers.defaultConfigurer;

  var config = standard()
      .setEvaluationContextConfigurer(defaultConfigurer());
  ```

- After (v3):

  ```java
  import static pro.verron.officestamper.preset.EvaluationContextFactories.defaultFactory;

  var config = standard()
      .setEvaluationContextFactory(defaultFactory());
  ```

- Custom (v2.x):

  ```java
  config.setEvaluationContextConfigurer(ctx -> {
      ctx.setTypeLocator(myTypeLocator);
      ctx.setBeanResolver(myBeanResolver);
  });
  ```

- Custom (v3):

  ```java
  config.setEvaluationContextFactory(root -> {
      var ctx = new StandardEvaluationContext(root);
      ctx.setPropertyAccessors(List.of(DataBindingPropertyAccessor.forReadWriteAccess(), new MapAccessor()));
      ctx.setMethodResolvers(List.of(DataBindingMethodResolver.forInstanceMethodInvocation()));
      ctx.setTypeLocator(myTypeLocator);
      ctx.setBeanResolver((context, name) -> { throw new AccessException("Bean resolution not supported"); });
      return ctx;
  });
  ```

Notes and consequences:

- If you mutated a context previously, now build and return it.
- Update any references to `EvaluationContextConfigurer` or `EvaluationContextConfigurers`.
- The engine wraps your `EvaluationContextFactory` with `OfficeStamperEvaluationContextFactory` to inject configured
  functions, comment processors, and union resolvers.

### Processing loop in v3 (for reference)

In v3, each hook runs with a context branch and a freshly built evaluation context:

```java
private void processTextualPart(DocxPart part, Object contextRoot) {
    var contextTree = new ContextTree(contextRoot);
    var iterator = DocxIterator.ofHooks(part::content, part);
    while (iterator.hasNext()) {
        var hook = iterator.next();
        if (hook.isPresent()) {
            var h = hook.get();
            var officeStamperEvaluationContextFactory = computeEvaluationContext();
            if (h.run(engineFactory, contextTree, officeStamperEvaluationContextFactory)) iterator.reset();
        }
    }
}
```

## üß™ Who should test carefully?

Minimal impact:

- If you use standard configurations and no custom processors, expect minimal changes beyond potential resolution order
  differences.

Critical testing required if you:

- Have custom processors that relied on placeholder resolution internals
- Use complex templates where comments and placeholders interact on the same lines
- Depend on the exact v2.x processing order

Known template gotchas to check:

- Conditional comments that previously ‚Äúsaw‚Äù placeholder results resolved earlier in the pass.
- Adjacent runs where a smart tag and a comment start/end share the same paragraph.

## üìã How to test the preview

See PR #609 for the full diff and discussion.

Focus testing on:

1. Templates with mixed comments and placeholders
2. Custom processor implementations
3. Complex SpEL expressions that might be order-dependent
4. Any edge cases in your document generation

## üìö Migration guide (checklist)

- Upgrade your dependencies to v3 pre‚Äërelease or final.
- Replace `EvaluationContextConfigurer` usages with `EvaluationContextFactory`.
- If you constructed `Engine` manually, pass `ExpressionParser` instead of `ExpressionResolver`.
- Review custom `CommentProcessor` implementations: remove reliance on `PlaceholderReplacer` injection; use
  `ProcessorContext` and `Hook` instead.
- Validate templates where comments and placeholders are adjacent; adjust if your logic assumed v2.x ordering.
- If you extend preset packages, review renamed utilities under `pro.verron.officestamper.preset` (e.g.,
  `EvaluationContextFactories`).
- Run your test suite; add explicit tests for nested contexts (repeaters referencing outer variables).

## üóìÔ∏è Timeline & feedback

Target release date: December 14, 2025

Please report via GitHub Issues tagged `v3-review`:

- Breaking changes you encountered
- Documentation gaps in this guide
- Performance regressions or improvements
- Missing functionality vs v2.x

Thank you for helping ensure a smooth transition!
