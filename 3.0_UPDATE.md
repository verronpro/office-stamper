# Office-stamper Update Guide

This document tracks major changes and migration steps for recent versions of Office-stamper.

## üöÄ Migration from 3.0 to 3.1

Office-stamper 3.1 continues the work started in 3.0 to streamline the API and improve maintainability. While less
revolutionary than 3.0, it contains several breaking changes due to package reorganization and removal of internal-only
classes that were previously exposed.

### üì¶ Package Reorganization (BREAKING)

Several core interfaces have been moved to the `pro.verron.officestamper.api` package to consolidate the public API:

- `PlaceholderHooker`
- `CommentHooker`
- `HookRemover`

If you were using these in your configuration or custom extensions, you will need to update your imports.

Additionally, all experimental features have been moved to `pro.verron.officestamper.experimental`. For example:

- `ExperimentalStampers` is now in `pro.verron.officestamper.experimental`.

### üßπ Internal API Cleanup (BREAKING)

To reduce the surface area of the public API and allow for future optimizations, several internal utility classes have
been removed or made private. These were not intended for public use, but were previously accessible:

- `SectionUtil`
- `RemoveTagsProcessor`
- `TagsVisitor`
- `ParagraphCollector`
- `CRSCollector`
- `PrepareCommentProcessors`

If your code relied on these, you should look for alternatives within the stable API or copy the necessary logic to your
own project.

### üõ†Ô∏è Post-processing Changes (BREAKING)

The `cleanTags` functionality, previously used to remove smart tags after processing, has been replaced by a more
flexible post-processor:

- Use `Postprocessors.removeTags(String)` instead of any old `cleanTags` methods.

### üìù Logging Improvements

Logging levels have been refined. Many messages that were previously at the `DEBUG` level are now at `TRACE`. If you are
troubleshooting the engine, you may need to enable `TRACE` logging to see the full execution flow.

---

## 3.0 Update Guide

Office‚Äëstamper 3.0 modernized the core processing algorithm and configuration API.

## üîÑ What changed (at a glance)

### Processing order overhaul

The most significant update: all elements (placeholders and comments) are now processed in document order of
appearance. Previously, processing was grouped (comments first with enclosed placeholders, then inline processors,
then left‚Äëover placeholders).

What this means for you:

- If you had comments and placeholders on the same lines, resolution order will change.
- More predictable and intuitive processing flow
- Better support for interdependent elements

### Custom processors and context

- Removal of the old `ParagraphPlaceholder` injection into custom `CommentProcessor` implementations.
- New hierarchical context system with `ContextTree` and `ContextBranch` that manages nested scopes for evaluation.
- Processors receive a `ProcessorContext` and should iterate over the hooks context they want to update with nested scopes.
- Cleaner separation of concerns: processors focus on document changes; the engine handles expression evaluation.

### Nested context resolution and evaluation context

- `OfficeStamperEvaluationContextFactory` now creates a fresh `EvaluationContext` per hook.
- Union resolvers (`UnionPropertyAccessor`, `UnionIndexAccessor`, `UnionMethodResolver`) resolve properties, indexes,
  and methods along the current `ContextBranch` from deepest to root (with shadowing semantics).
- Placeholders inside repeated/nested structures can reference values defined in outer scopes.
- No config changes required to benefit from this; it is built into v3.

### API cleanup

- All deprecated methods removed.
- `DocxDocument` interface removed (merged into `DocxPart`).
- Unnecessary setters removed for better immutability.
- Streamlined configuration API.
- Removed `ExpressionResolver` in favor of using an `ExpressionParser` (typically `SpelExpressionParser`) inside
  `Engine` (BREAKING). If you previously constructed `Engine` with an `ExpressionResolver`, now pass an
  `ExpressionParser` instance instead.
- `Comment` interface: removed `getDocument()`.
- `CommentUtil`: `createSubWordDocument` now requires a `sourceDocument` parameter.
- `ContextDependent` interface renamed to `Hook`.
- `DocxStamper#stamp` now returns the document.

### Pluggable expression parsing

The engine now accepts a generic `org.springframework.expression.ExpressionParser` throughout. You can:

- Keep using SpEL (default). Construct `SpelExpressionParser` with your `SpelParserConfiguration` and pass it into the
  configuration.
- Swap in an alternative `ExpressionParser` implementation if you prefer not to depend on SpEL.

Migration examples:

- Before (v2.x; parser implicit):

  ```java
  // v2.x style (conceptual):
  var config = standard();
  // SpEL features were controlled via SpelParserConfiguration in internal components.
  ```

- After (v3): pass an `ExpressionParser` explicitly

  ```java
  import org.springframework.expression.ExpressionParser;
  import org.springframework.expression.spel.SpelParserConfiguration;
  import org.springframework.expression.spel.standard.SpelExpressionParser;

  var spelConfig = new SpelParserConfiguration(true, true); // auto-grow lists, null-safe navigation, etc.
  ExpressionParser parser = new SpelExpressionParser(spelConfig);

  var config = standard()
      .setExpressionParser(parser);
  ```

Notes:

- SpEL remains the default. Providing your own parser is optional.
- With SpEL, language features are controlled at parser construction time via `SpelParserConfiguration`.
- Any custom parser must implement Spring‚Äôs `ExpressionParser` interface.

### EvaluationContext: Configurer ‚Üí Factory (BREAKING)

`EvaluationContextConfigurer` has been replaced with `EvaluationContextFactory` (creation over mutation). This aligns
with hierarchical context and avoids side effects when multiple contexts are created during processing.

What changed:

- Interface rename and responsibility shift:
    - `EvaluationContextConfigurer#configureEvaluationContext(StandardEvaluationContext)` ‚Üí
      `EvaluationContextFactory#create(Object root)` returning a new `EvaluationContext`.
- Preset utilities renamed and modernized:
    - `EvaluationContextConfigurers.defaultConfigurer()` ‚Üí `EvaluationContextFactories.defaultFactory()`
    - `EvaluationContextConfigurers.noopConfigurer()` ‚Üí `EvaluationContextFactories.noopFactory()`
- Configuration API now expects a factory via `OfficeStamperConfiguration#setEvaluationContextFactory(...)`.

Why this matters:

- Each evaluation context is created fresh for a root object/branch, avoiding cross‚Äëcontamination between steps.
- Safer defaults: the default factory restricts dangerous features (constructor/method resolution, type lookup, bean
  resolution) but allows map and data‚Äëbinding accessors.
- Clearer lifecycle: no mutating a shared `StandardEvaluationContext`; always return a fully configured context.

Migration examples:

- Before (v2.x):

  ```java
  import static pro.verron.officestamper.preset.EvaluationContextConfigurers.defaultConfigurer;

  var config = standard()
      .setEvaluationContextConfigurer(defaultConfigurer());
  ```

- After (v3):

  ```java
  import static pro.verron.officestamper.preset.EvaluationContextFactories.defaultFactory;

  var config = standard()
      .setEvaluationContextFactory(defaultFactory());
  ```

- Custom (v2.x):

  ```java
  config.setEvaluationContextConfigurer(ctx -> {
      ctx.setTypeLocator(myTypeLocator);
      ctx.setBeanResolver(myBeanResolver);
  });
  ```

- Custom (v3):

  ```java
  config.setEvaluationContextFactory(root -> {
      var ctx = new StandardEvaluationContext(root);
      ctx.setPropertyAccessors(List.of(DataBindingPropertyAccessor.forReadWriteAccess(), new MapAccessor()));
      ctx.setMethodResolvers(List.of(DataBindingMethodResolver.forInstanceMethodInvocation()));
      ctx.setTypeLocator(myTypeLocator);
      ctx.setBeanResolver((context, name) -> { throw new AccessException("Bean resolution not supported"); });
      return ctx;
  });
  ```

Notes and consequences:

- If you mutated a context previously, now build and return it.
- Update any references to `EvaluationContextConfigurer` or `EvaluationContextConfigurers`.
- The engine wraps your `EvaluationContextFactory` with `OfficeStamperEvaluationContextFactory` to inject configured
  functions, comment processors, and union resolvers.

### Processing loop in v3 (for reference)

In v3, each hook runs with a context tree and a freshly built evaluation context:

```java
private void process(DocxPart part, Object contextRoot) {
    var contextTree = new ContextRoot(contextRoot);
    var iterator = DocxHook.ofHooks(part::content, part);
    while (iterator.hasNext()) {
        var hook = iterator.next();
        var officeStamperContextFactory = new OfficeStamperEvaluationContextFactory(customFunctions,
                commentProcessors,
                interfaceFunctions,
                contextFactory);
        if (hook.run(engineFactory, contextTree, officeStamperContextFactory)) {
            iterator.reset();
        }
    }
}
```

## üß™ Who should test carefully?

Minimal impact:

- If you use standard configurations and no custom processors, expect minimal changes beyond potential resolution order
  differences.

Critical testing required if you:

- Have custom processors that relied on placeholder resolution internals
- Use complex templates where comments and placeholders interact on the same lines
- Depend on the exact v2.x processing order

Known template gotchas to check:

- Conditional comments that previously ‚Äúsaw‚Äù placeholder results resolved earlier in the pass.
- Adjacent runs where a smart tag and a comment start/end share the same paragraph.

## üìã How to test the preview

See PR #609 for the full diff and discussion.

Focus testing on:

1. Templates with mixed comments and placeholders
2. Custom processor implementations
3. Complex SpEL expressions that might be order-dependent
4. Any edge cases in your document generation

## üìö Migration guide (checklist)

- Upgrade your dependencies to v3 pre‚Äërelease or final.
- Replace `EvaluationContextConfigurer` usages with `EvaluationContextFactory`.
- If you constructed `Engine` manually, pass `ExpressionParser` instead of `ExpressionResolver`.
- Review custom `CommentProcessor` implementations: remove reliance on `PlaceholderReplacer` injection; use
  `ProcessorContext` and `Hook` instead.
- Validate templates where comments and placeholders are adjacent; adjust if your logic assumed v2.x ordering.
- If you extend preset packages, review renamed utilities under `pro.verron.officestamper.preset` (e.g.,
  `EvaluationContextFactories`).
- Run your test suite; add explicit tests for nested contexts (repeaters referencing outer variables).

## üóìÔ∏è Timeline & feedback

Target release date: December 14, 2025

Please report via GitHub Issues tagged `v3-review`:

- Breaking changes you encountered
- Documentation gaps in this guide
- Performance regressions or improvements
- Missing functionality vs v2.x

Thank you for helping ensure a smooth transition!
