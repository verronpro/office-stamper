Hello!

Version 3.0 is approaching release and includes significant changes to the core processing algorithm. These changes
improve consistency and fix long-standing ordering issues, but require careful review due to potential breaking changes
in specific scenarios.

## üîÑ Core Algorithm Changes Requiring Your Attention

### **Processing Order Revolution**

The most significant update: **all elements (placeholders, comments) are now processed in document order of appearance
**, rather than the previous grouped approach (comments first, then inline processors, then placeholders).

**What this means for you:**

- If you had comments and placeholders on the same lines, resolution order will change
- More predictable and intuitive processing flow
- Better support for interdependent elements

### **Custom Processor API Updates**

- **Removal of ParagraphPlaceholder injection** from custom CommentProcessor implementations
- **New hierarchical context system**: Introduction of `ContextTree` and `ContextBranch` for managing resolution
  contexts
- **Context annotation approach**: Comment and tag hooks are now annotated with descriptions of the context to use for
  resolution
- The engine automatically resolves placeholders using the appropriate context when processing elements
- Cleaner separation of concerns

### **Nested Context Resolution and Evaluation Context**

- Introduction of `OfficeStamperEvaluationContextFactory` that produces a per‚Äëhook evaluation context powering
  property/index resolution across nested contexts created by `ContextTree`/`ContextBranch`.
- New union accessors and resolvers: `UnionPropertyAccessor`, `UnionIndexAccessor`, and `UnionMethodResolver`
  (collectively ‚Äúunion resolvers‚Äù) to transparently resolve properties, indexed values, and method calls across stacked
  contexts.
- Resolution now walks up the context branch: when a property (or index/method) cannot be resolved on the current (
  deepest)
  context, the engine automatically tries the parent context, continuing upward until the root is reached.
    - This enables placeholders inside repeated/nested structures to reference values defined in outer scopes.
    - Shadowing still works: a value defined in a deeper context takes precedence over the same name in outer contexts.
- No configuration change is required to benefit from this; custom processors and templates will automatically use the
  new resolution semantics.

### **API Cleanup**

- **All deprecated methods removed** - please check your migration path
- **Unnecessary setters eliminated** for better immutability
- Streamlined configuration API
- Removed `ExpressionResolver` in favor of using `SpelExpressionParser` directly inside `Engine` (BREAKING). If you
  previously constructed `Engine` with an `ExpressionResolver`, now pass a `SpelExpressionParser` instance instead.
  No behavior change is expected beyond the constructor signature. Evaluation still uses SpEL and the per‚Äëhook
  `EvaluationContext` produced by `OfficeStamperEvaluationContextFactory`.

### Expression parsing is now pluggable (reduced hard dependency on SpEL)

We now accept a generic `org.springframework.expression.ExpressionParser` throughout the engine. This allows you to:

- Keep using SpEL (default) with your preferred `SpelParserConfiguration` by constructing a
  `SpelExpressionParser` yourself and providing it to the configuration.
- Swap in an alternative implementation of `ExpressionParser` if you do not want to depend on SpEL.

Migration examples:

- Before (passing configuration only, implicitly creating the parser):

  ```java
  // v2 style (conceptual):
  var config = standard();
  // SpEL features were controlled via SpelParserConfiguration in internal components.
  ```

- After (v3): pass an `ExpressionParser` instance explicitly

  ```java
  import org.springframework.expression.ExpressionParser;
  import org.springframework.expression.spel.SpelParserConfiguration;
  import org.springframework.expression.spel.standard.SpelExpressionParser;

  var spelConfig = new SpelParserConfiguration(true, true); // auto-grow lists, null-safe navigation, etc.
  ExpressionParser parser = new SpelExpressionParser(spelConfig);

  var config = standard()
      .setExpressionParser(parser);
  ```

Notes:

- SpEL remains the default in the out-of-the-box configuration. Providing your own parser is optional.
- If you use SpEL, all language features are now controlled at parser construction time via `SpelParserConfiguration`.
- Custom or alternative parsers can be used as long as they implement Spring‚Äôs `ExpressionParser` interface.

### **EvaluationContext: Configurer ‚Üí Factory (BREAKING)**

We replaced the `EvaluationContextConfigurer` interface with the new `EvaluationContextFactory` (creation over
mutation). This aligns with the new hierarchical context system and prevents side effects when multiple evaluation
contexts are created during processing.

What changed:

- Interface rename and responsibility shift:
    - `EvaluationContextConfigurer#configureEvaluationContext(StandardEvaluationContext ctx)` ‚Üí replaced by
      `EvaluationContextFactory#create(Object root)` which must return an `EvaluationContext` instance.
- Preset utilities renamed and modernized:
    - `EvaluationContextConfigurers.defaultConfigurer()` ‚Üí `EvaluationContextFactories.defaultFactory()`
    - `EvaluationContextConfigurers.noopConfigurer()` ‚Üí `EvaluationContextFactories.noopFactory()`
- Configuration API now expects a factory:
    - `OfficeStamperConfiguration#setEvaluationContextFactory(EvaluationContextFactory)`
    - `OfficeStamperConfiguration#getEvaluationContextFactory()`

Why this matters:

- Each evaluation context is now created fresh for a given root object/branch, avoiding accidental cross‚Äëcontamination
  between processing steps.
- Safer defaults: the default factory restricts dangerous features (constructor/method resolution, type lookup, bean
  resolution) while still allowing map and data‚Äëbinding accessors.
- Clearer lifecycle: no more mutating a shared `StandardEvaluationContext`; you always return a fully configured
  context.

Migration examples:

- Before (v2.x style):

  ```java
  import static pro.verron.officestamper.preset.EvaluationContextConfigurers.defaultConfigurer;

  var config = standard()
      .setEvaluationContextConfigurer(defaultConfigurer());
  ```

- After (v3):

  ```java
  import static pro.verron.officestamper.preset.EvaluationContextFactories.defaultFactory;

  var config = standard()
      .setEvaluationContextFactory(defaultFactory());
  ```

- Custom (v2.x style):

  ```java
  config.setEvaluationContextConfigurer(ctx -> {
      ctx.setTypeLocator(myTypeLocator);
      ctx.setBeanResolver(myBeanResolver);
  });
  ```

- Custom (v3):

  ```java
  config.setEvaluationContextFactory(root -> {
      var ctx = new StandardEvaluationContext(root);
      ctx.setPropertyAccessors(List.of(DataBindingPropertyAccessor.forReadWriteAccess(), new MapAccessor()));
      ctx.setMethodResolvers(List.of(DataBindingMethodResolver.forInstanceMethodInvocation()));
      ctx.setTypeLocator(myTypeLocator);
      ctx.setBeanResolver((context, name) -> { throw new AccessException("Bean resolution not supported"); });
      return ctx;
  });
  ```

Notes and consequences:

- If you previously relied on mutating a context passed to you, you must now build and return one instead.
- Tests or code referencing `EvaluationContextConfigurer` or `EvaluationContextConfigurers` must be updated to the new
  `EvaluationContextFactory` and `EvaluationContextFactories` names and methods.
- The engine internally wraps your `EvaluationContextFactory` with `OfficeStamperEvaluationContextFactory` to inject
  configured functions and comment processors, and to integrate with the new `ContextTree`/`ContextBranch` and union
  resolvers.

### Processing loop in v3

In v3, each hook runs with a context branch and a freshly built evaluation context:

```java
private void processTextualPart(DocxPart part, Object contextRoot) {
    var contextTree = new ContextTree(contextRoot);
    var iterator = DocxIterator.ofHooks(part::content, part);
    while (iterator.hasNext()) {
        var hook = iterator.next();
        if (hook.isPresent()) {
            var h = hook.get();
            var officeStamperEvaluationContextFactory = computeEvaluationContext();
            if (h.run(engineFactory, contextTree, officeStamperEvaluationContextFactory)) iterator.reset();
        }
    }
}
```

## üß™ Who Needs to Pay Special Attention?

### **Minimal Impact**

If you use office-stamper with standard configurations and no custom processors, you likely won't notice significant
changes beyond potential resolution order issues.

### **Critical Testing Required** If You:

- Have custom processors that relied on the placeholder resolver
- Use complex templates with comments and placeholders interacting on the same lines
- Depend on the specific processing order of v2.x

## üìã How to Test the Preview

You can find the PR #609

**Focus your testing on:**

1. Templates with mixed comments and placeholders
2. Custom processor implementations
3. Complex SpEL expressions that might be order-dependent
4. Any edge cases in your document generation

## üìö Migration Guide & Documentation

- To do

## üóìÔ∏è Timeline & Feedback

**Target release date**: December 14, 2025

**Please report:**

- Any feedback related to your use case.
- Any breaking changes in your specific use cases
- Documentation gaps in the migration guide
- Performance regressions or improvements
- Missing functionality from v2.x

Submit feedback via GitHub Issues tagged with `v3-review` or join the discussion directly.

Your expertise is invaluable in ensuring a smooth transition!
